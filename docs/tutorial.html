<html>
<head>
  <title>Kanso - Tutorial</title>
  <link rel="stylesheet" href="http://yandex.st/highlightjs/5.16/styles/github.min.css">
  <link rel="stylesheet" href="stylesheets/kanso.css" />
</head>
<body>
  <div id="topbar"></div>
  <div id="topbar_overlay"></div>
  <div id="container">

    <ul id="navigation">
      <li><a href="index.html">Intro</a></li>
      <li><a class="selected" href="tutorial.html">Tutorial</a></li>
      <li><a href="docs.html">Docs</a></li>
      <li><a href="https://github.com/caolan/kanso">Code &rArr;</a></li>
    </ul>

    <a id="sitename" href="index.html">
      <img src="images/kanso_ribbon.png" />
    </a>

    <!-- populated by javascript -->
    <ul id="sidenav"></ul>

    <h1>Getting started</h1>

    <h2 id="installation">Installation</h2>
    <p>
      Install the most recent <em>stable</em> version of
      <a href="http://nodejs.org/#download">node</a>, then clone
      <a href="https://github.com/caolan/kanso">kanso</a> from GitHub.
      Fetch the relevant submodules by doing the following in the cloned directory:
    </p>
    <pre>git submodule init
git submodule update</pre>
    <p>You are then ready to install:</p>
    <pre>make &amp;&amp; sudo make install</pre>

    <h3>Using NPM</h3>
    <p>
    If you already have node.js installed, and you're using npm
    (Node Package Manager), then you can install by simply doing the following:
    </p>
    <pre>npm install kanso</pre>

    <h2 id="starting_a_project">Starting a project</h2>
    <p>
      For this tutorial we'll be making a fairly typical blog, with posts,
      comments and users. Some familiarity with CouchDB is expected, but I'll
      try to explain the concepts as we go.
    </p>
    <p>
      To create a new project skeleton, enter the following command:
    </p>
    <pre>kanso create myblog</pre>
    <p>
      This creates a number of files and directories representing a basic
      project structure. We'll look more closely at the generated files later,
      but for a brief overview, the directories fall into the following categories:
    </p>
    <pre>myblog
  |- lib             CommonJS modules which define your app
  |- static          Static files such as jQuery and CSS
  |- templates       HTML templates used by the app
  |- kanso.json      Project configuration
    </pre>
    <p>
      This structure is a merely a guide and you are free to place files
      wherever it makes sense, provided you update the configuration settings in
      kanso.json.
    </p>

    <h2 id="deployment">Deployment</h2>
    <p>
      It might seem early in the tutorial to start talking about deployment, but
      since your app needs to be hosted by CouchDB to run, we're going to cover it
      now.
    </p>
    <p>
      The first thing to mention is that <em>Kanso apps are just CouchApps</em>. This means
      they can be hosted directly from your CouchDB instance, without any additional
      tier or services.
    </p>
    <p>
      For the rest of this tutorial we're going to assume you have CouchDB running
      on <a href="http://localhost:5984">http://localhost:5984</a>
      (the default settings). If you haven't got a local copy of CouchDB running,
      go do that now.
    </p>

    <h3>Pushing</h3>
    <p>
      The <code>push</code> command uploads your app to a CouchDB database. You can find help
      on any of the commands used in this tutorial by typing <code>kanso help</code>.
    </p>
    <p>
      Let's push the new project to your CouchDB instance, and check that everthing
      works. To do this, enter the following command from your project directory:
    </p>
    <pre>kanso push http://localhost:5984/myblog</pre>
    <img src="images/deployment1.png" alt="pushing myblog" />
    <p>
      This creates a new database called 'myblog' and uploads your app to it.
      If you now visit <a href="http://localhost:5984/myblog/_design/myblog/_rewrite/">http://localhost:5984/myblog/_design/myblog/_rewrite/</a>,
      you should see the following welcome page:
    </p>
    <img src="images/deployment2.png" alt="pushing myblog" />
    <p>
      This is the location to use when testing your app. Don't worry about the
      ugly URL, we can fix this later using
      <a href="http://wiki.apache.org/couchdb/Virtual_Hosts">virtual hosts</a>.
    </p>

    <h2 id="describing_the_data">Describing the data</h2>
    <p>
      Now we've got our new project up and running, let's think about the data
      structures this project requires. Because CouchDB is schemaless, we can make
      lots of changes as we go without having to worry about doing ALTER TABLE.
    </p>
    <p>
      The only problem is, it can quickly get complicated when manually validating
      documents and checking permissions. Thankfully, kanso provides a powerful
      document validation and permissions tool in the form of Type definitions.
    </p>
    <h3>Creating types</h3>
    <p>
      In the skeleton project we created earlier, there's a file called
      <code>lib/types.js</code>. This is the conventional place to export types.
      Remember, the files in the <code>lib</code> directory are 
      <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS modules</a>.
      This means anything added to the <code>exports</code> object in this file is
      made visible to other modules.
    </p>
    <p>
      Let's create a type for describing blog posts. Add the following to
      <code>lib/types.js</code>.
    </p>
    <pre><code class="javascript">var Type = require('kanso/types').Type,
    fields = require('kanso/fields'),
    widgets = require('kanso/widgets');


exports.blogpost = new Type('blogpost', {
    fields: {
        created: fields.timestamp(),
        title: fields.string(),
        text: fields.string({
            widget: widgets.textarea({cols: 40, rows: 10})
        })
    }
});
</code></pre>
    <p>
      That should be fairly self-explanatory.
      The first argument to the <code>Type</code> constructor is the type name
      which must be unique, the second argument is an object describing fields
      and other options.
    </p>
    <p>
      Now we've added a basic type, let's push these changes to the server:
    </p>
    <img src="images/deployment1.png" alt="pushing myblog" />

    <h3>The Admin App</h3>
    <p>
      As a useful way to play with data types, kanso provides a basic admin app.
      You can push this app to the same database you pushed the 'myblog' project to
      by using the following command:
    </p>
    <pre>kanso pushadmin http://localhost:5984/myblog</pre>
    <img src="images/describing_the_data1.png" alt="push the admin app" />
    <p>
      If you now visit
      <a href="http://localhost:5984/myblog/_design/admin/_rewrite/">http://localhost:5984/myblog/_design/admin/_rewrite/</a>
      you should see the following page:
    </p>
    <img src="images/describing_the_data2.png" alt="admin app - apps list" />
    <p>
      Because you can have multiple apps running on a single database you will be
      presented with a list of available applications. Click the 'myblog' app.
    </p>
    <img src="images/describing_the_data3.png" alt="admin app - app overview" />
    <p>
      Here, we are presented with a list of types. Currently, we just have the one
      'blogpost' type. Clicking on this will show you a list of existing blog posts:
    </p>
    <img src="images/describing_the_data4.png" alt="admin app - type list" />
    <p>
      Of course, we haven't added any yet. Let's try adding one now. Click the
      'Add blogpost' link.
    </p>
    <img src="images/describing_the_data5.png" alt="admin app - adding a type" />
    <p>
      As you can see, the admin app has read the field settings we defined earlier
      and presented us with a sensible form for adding blog posts. You'll notice the
      <code>timestamp</code> field is missing. This is because it's automatically
      populated with the current time.
    </p>
    <p>
      Create a blog post by filling out the form with some test data and clicking
      the create button.
    </p>
    <img src="images/describing_the_data6.png" alt="admin app - type added" />
    <p>
      As you can see, kanso has automatically populated the 'type' and 'created'
      fields. The 'type' field is automatically added, and reserved for use by
      kanso so we can identify the definition to validate against.
    </p>
    

    <h2 id="querying_the_data">Querying the data</h2>
    <p>
      In CouchDB, you query your documents using map / reduce functions called
      'views'. If you've never written a CouchDB view before, you can read up on
      it in the <a href="http://guide.couchdb.org/draft/views.html">Definitive Guide</a>.
    </p>
    <p>
      Adding a view to a kanso app couldn't be simpler. Just open up the
      <code>lib/views.js</code> file and add the following example view:
    </p>
    <pre><code class="javascript">exports.blogposts_by_created = {
    map: function (doc) {
        if (doc.type === 'blogpost') {
            emit(doc.created, doc.title);
        }
    }
};</code></pre>
    <p>
      <strong>Push the app</strong>, then revisit the admin interface at
      <a href="http://localhost:5984/myblog/_design/admin/_rewrite/myblog">http://localhost:5984/myblog/_design/admin/_rewrite/myblog</a>
      you'll see the view we created now appears:
    </p>
    <img src="images/querying_the_data1.png" alt="admin app - now showing a view" />
    <p>
      Clicking on the view shows the current results. You should see the document
      we created earlier keyed by its created at timestamp:
    </p>
    <img src="images/querying_the_data2.png" alt="admin app - view results" />
    <p>
      Clicking on a row will take you to its corresponding document.
    </p>

    <h2 id="rendering_pages">Rendering pages</h2>
    <p>
      In CouchDB, rendering custom representations of your data is achieved using
      <a href="http://wiki.apache.org/couchdb/Formatting_with_Show_and_List">List and Show functions</a>.
      Kanso is no different, although it will also run these functions client-side
      wherever possible, giving users a more responsive interface while also
      providing a fallback for search-engines.
    </p>
    <p>
      Writing code in this way can be very efficient and shows where you might be
      missing non-js support. However, at first it might seem a little odd. Work
      through the examples and bear in mind that all list and show functions could
      be run client-side or server-side at any time!
    </p>
    <h3>List functions</h3>
    <p>
      List functions format the results of a view. We're going to use a list
      function to show a list of blog posts on the homepage, ordered by the
      date they were created. Add the following to <code>lib/lists.js</code>:
    </p>
    <pre><code class="javascript">var templates = require('kanso/templates');


exports.homepage = function (head, req) {

    start({code: 200, headers: {'Content-Type': 'text/html'}});

    // fetch all the rows
    var row, rows = [];
    while (row = getRow()) {
        rows.push(row);
    }

    // generate the markup for a list of blog posts
    var content = templates.render('blogposts.html', req, {
        rows: rows
    });

    if (req.client) {
        // being run client-side, update the current page
        $('#content').html(content);
        document.title = 'MyBlog';
    }
    else {
        // being run server-side, return a complete rendered page
        return templates.render('base.html', req, {
            content: content,
            title: 'MyBlog'
        });
    }

};</code></pre>
    <p>
      For simplicity, we're pre-fetching all the rows at once, on large views
      you'll want to return content for each row before fetching the next.
    </p>
    <p>
      You'll notice this list function detects if its running client-side by
      checking the client property on the request object. When run client-side,
      it will update the DOM instead of returning a new HTML document.
    </p>
    <p>
      We also reference two templates: 'base.html' and 'blogposts.html'. The first
      was created as part of the project skeleton, but the second we need to create
      ourselves. Create a new template at <code>templates/blogposts.html</code> with
      the following content:
    </p>
    <pre><code>&lt;h1&gt;My Blog&lt;/h1&gt;

{?rows}
  &lt;ul&gt;
    {#rows}
      &lt;li&gt;{value}&lt;/li&gt;
      &lt;li&gt;&lt;a href="{baseURL}/{id}"&gt;{value}&lt;/a&gt;&lt;/li&gt;
    {/rows}
  &lt;/ul&gt;
{:else}
  &lt;p&gt;No blog posts&lt;/p&gt;
{/rows}</code></pre>
    <p>
      For more information on the template format used by kanso, see the
      <a href="http://akdubya.github.com/dustjs/">Dust website</a>. Basically,
      this will render a list of blog post titles.
    </p>
    <p>
      One thing worth noting is the use of {baseURL} in the template. This variable
      is automatically made available to templates by kanso, and refers to the
      current 'root' level URL. That would currently mean
      '/myblog/_design/myblog/_rewrite', but that may change if you use
      a virtual host in the future. For now, be sure to prefix all
      <strong>application</strong> URLs with the base URL.
    </p>
    <h3>Rewrites</h3>
    <p>
      Next, we need to hook this view up to a URL. CouchDB uses
      <a href="http://wiki.apache.org/couchdb/Rewriting_urls">rewrites</a>
      to point arbitrary URLs at CouchDB functions and again, kanso is no exception.
      Let's change the root URL from the welcome page to our new list of blog posts.
      Edit <code>lib/rewrites.js</code> to look like the following:
    </p>
    <pre><code class="javascript">module.exports = [
    {from: '/static/*', to: 'static/*'},
    {from: '/', to: '_list/homepage/blogposts_by_created'}
];</code></pre>
    <p>
      This uses our new list function in combination with the view query we created
      earlier. <strong>Push the app</strong>, then open it in your browser:
      <a href="http://localhost:5984/myblog/_design/myblog/_rewrite/">http://localhost:5984/myblog/_design/myblog/_rewrite/</a>.
    </p>
    <img src="images/rendering_pages1.png" alt="The new homepage" />
    <p>
      Of course, clicking on the blog post will give a 404 Not Found error, since
      we've not implemented the view for a single blog post yet. Let's do that now.
    </p>
    <h3>Show functions</h3>
    <p>
      Show functions are like list functions, only they display a single document
      rather than the results of a view. We're going to create a show function
      for our blog posts, open up <code>lib/shows.js</code> and take a look.
      Currently, it will contain the welcome page we recently unhooked from our
      rewrite rules. You can now remove that, and replace it with the following:
    </p>
    <pre><code class="javascript">var templates = require('kanso/templates');


exports.blogpost = function (doc, req) {

    // render the markup for a single blog post
    var content = templates.render('blogpost.html', req, doc);

    if (req.client) {
        // being run client-side
        $('#content').html(content);
        document.title = doc.title;
    }
    else {
        return templates.render('base.html', req, {
            content: content,
            title: doc.title
        });
    }

};</code></pre>
    <p>
      Then we need to add the <code>blogpost.html</code> template:
    </p>
    <pre><code>&lt;h1&gt;{title}&lt;/h1&gt;

&lt;p&gt;{text}&lt;/p&gt;</code></pre>
    <p>
      And update the rewrite rules:
    </p>
    <pre><code class="javascript">module.exports = [
    {from: '/static/*', to: 'static/*'},
    {from: '/', to: '_list/homepage/blogposts_by_created'},
    {from: '/:id', to: '_show/blogpost/:id'}
];</code></pre>
    <p>
      <strong>Push the app</strong> and try clicking the blog post link now.
      You should see a page similar to the following:
    </p>
    <img src="images/rendering_pages2.png" alt="Single blog post page" />
    <p>
      If you check your JavaScript console in Chrome or Firebug, you should notice
      that clicking on the blog post link on the homepage causes the next request to
      be handled client-side:
    </p>
    <img src="images/rendering_pages3.png" alt="Single blog post page" />
    <p>
      However, turning off JavaScript should provide you with the same experience.
      Just with your CouchDB server doing the work of rending pages.
    </p>
    <p>
      As your sites become more complex you may want to make additional requests
      to the server when a list or show function is run client-side. This means
      we could show all blogposts with the same tag in a side-bar, or perhaps show
      links to related posts. These features would then be available only to people
      with JavaScript turned on, and browsers without JavaScript will fall-back to
      the core content you see now.
    </p>

    <h2 id="users_and_permissions">Users and permissions</h2>
    <h2 id="going_it_alone">Going it alone</h2>
  </div>

  <script src="http://yandex.st/highlightjs/5.16/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script src="javascript/docs.js"></script>
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-20477836-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</body>
</html>
